---
import { Image } from 'astro:assets';
import type { ImageMetadata } from 'astro';

export interface Item {
	image: ImageMetadata;
	caption?: string;
	alt?: string;
}

export interface Props {
	items: Item[];
	ariaLabel?: string;
}

const { items = [], ariaLabel = 'Screenshots' } = Astro.props as Props;
---

{items.length > 0 && (
	<section class="slider relative z-0" role="region" aria-label={ariaLabel} data-slider>
		{
			items.length > 1 && (
				<button class="nav prev left-0 absolute top-0 z-10 size-8 p-0 flex items-center justify-center leading-none bg-bg bg-opacity-50" type="button" aria-label="Previous screenshot">
					<svg class="size-6 mr-1px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="m15 18-6-6 6-6"/>
					</svg>
				</button>

				<button class="nav next right-0 absolute top-0 z-10 size-8 p-0 flex items-center justify-center leading-none bg-bg bg-opacity-50" type="button" aria-label="Next screenshot">
					<svg class="size-6 ml-1px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
						<path d="m9 18 6-6-6-6"/>
					</svg>
				</button>
			)
		}

		<div class="viewport" tabindex="0">
			<div class="track flex">
				{items.map((item) => (
					<figure class="slide relative m-0">
						<Image src={item.image} alt={item.alt || ''} class="slide-img" draggable={false} />

						{item.caption && (
							<figcaption class="text-sm absolute bottom-0 left-0 bg-bg bg-opacity-50 px-2 py-1 select-none pointer-events-none">{item.caption}</figcaption>
						)}
					</figure>
				))}
			</div>
		</div>
	</section>
)}

<script is:inline>
	(() => {
	const RAFT = (cb) => requestAnimationFrame(cb);

	const initSlider = (root) => {
		const viewport = root.querySelector('.viewport');
		const track = root.querySelector('.track');
		const prev = root.querySelector('.nav.prev');
		const next = root.querySelector('.nav.next');
		if (!viewport || !track || !prev || !next) return;

		let navUpdatePending = false;
		const getMax = () => Math.max(0, viewport.scrollWidth - viewport.clientWidth);
		const showNav = () => {
			const max = getMax();
			const sc = viewport.scrollLeft;
			const atStart = sc <= 2;
			const atEnd = sc >= max - 2;
			const overflow = max > 0;

			// Always show buttons if there is overflow, otherwise hide them.
			root.classList.toggle('has-overflow', overflow);

			// Toggle disabled state for prev/next buttons
			prev.classList.toggle('disabled', atStart);
			next.classList.toggle('disabled', atEnd);

			navUpdatePending = false;
		};

		const scheduleNavUpdate = () => {
			if (navUpdatePending) return;
			navUpdatePending = true;
			RAFT(showNav);
		}

		const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
		const scrollByPage = (dir) => {
			const delta = viewport.clientWidth * dir;
			const max = getMax();
			const target = Math.max(0, Math.min(max, viewport.scrollLeft + delta));
			try {
				viewport.scrollTo({ left: target, behavior: prefersReduced ? 'auto' : 'smooth' });
			} catch (_) {
				viewport.scrollLeft = target; // Fallback
			}
		};

		// Drag-to-scroll using Pointer Events
		let dragging = false;
		let startX = 0;
		let startLeft = 0;
		let moved = false;
		let currentX = 0;
		const onDown = (e) => {
			dragging = true;
			startX = e.clientX;
			currentX = e.clientX;
			startLeft = viewport.scrollLeft;
			// Temporarily disable smooth scrolling and snapping for instant drag response
			viewport.classList.add('dragging');
			viewport.classList.add('no-snap');
			viewport.style.scrollBehavior = 'auto';
			viewport.setPointerCapture && viewport.setPointerCapture(e.pointerId);
			moved = false;
		};
		const onMove = (e) => {
			if (!dragging) return;
			e.preventDefault(); // Prevent text selection, etc.
			currentX = e.clientX;
			const dx = currentX - startX;
			if (Math.abs(dx) > 2) moved = true;
			
			// Update scroll position directly for maximum responsiveness
			viewport.scrollLeft = startLeft - dx;
		};
		const onUp = (e) => {
			const dx = currentX - startX;
			const dragThreshold = viewport.clientWidth * 0.2; // 20% threshold
			
			dragging = false;
			viewport.classList.remove('dragging');
			viewport.classList.remove('no-snap');
			viewport.releasePointerCapture && viewport.releasePointerCapture(e.pointerId);

			const wasMoved = moved;
			moved = false; // Reset for next interaction

			// If a drag happened, prevent the upcoming click event from firing on the target.
			// This is done by capturing the next click on the window and stopping it.
			if (wasMoved) {
				const swallowClick = (evt) => {
					evt.preventDefault();
					evt.stopPropagation();
					window.removeEventListener('click', swallowClick, { capture: true });
				};
				window.addEventListener('click', swallowClick, { capture: true, once: true });
			}
			
			// If dragged past threshold, animate to the next/prev slide.
			if (Math.abs(dx) > dragThreshold) {
				// Re-enable smooth scroll for the completion animation, then scroll.
				viewport.style.scrollBehavior = prefersReduced ? 'auto' : 'smooth';
				if (dx > 0) {
					scrollByPage(-1); // Dragged right (go to previous)
				} else {
					scrollByPage(1); // Dragged left (go to next)
				}
			} else if (wasMoved) {
				// If the drag was short, restore the original scroll behavior.
				// The browser's native scroll-snap will handle snapping back.
				viewport.style.scrollBehavior = '';
			}
		};

		prev.addEventListener('click', () => scrollByPage(-1));
		next.addEventListener('click', () => scrollByPage(1));

		viewport.addEventListener('scroll', scheduleNavUpdate);
		window.addEventListener('resize', scheduleNavUpdate);
		viewport.addEventListener('pointerdown', onDown);

		// With setPointerCapture, subsequent events are dispatched to the viewport
		// even if the cursor leaves the element. 'pointerleave' is not needed.
		viewport.addEventListener('pointermove', onMove);
		viewport.addEventListener('pointerup', onUp);
		viewport.addEventListener('pointercancel', onUp);

		viewport.addEventListener('keydown', (e) => {
			if (e.key === 'ArrowLeft') { e.preventDefault(); scrollByPage(-1); }
			if (e.key === 'ArrowRight') { e.preventDefault(); scrollByPage(1); }
		});

		// Prevent image drag ghost and recalc when images load
		root.querySelectorAll('img').forEach((img) => {
			img.addEventListener('dragstart', (e) => e.preventDefault());
			if (!img.complete) {
				img.addEventListener('load', scheduleNavUpdate, { once: true });
			}
		});

		// Recalculate on load and when sizes change
		window.addEventListener('load', scheduleNavUpdate);
		if ('ResizeObserver' in window) {
			const ro = new ResizeObserver(scheduleNavUpdate);
			ro.observe(viewport);
			ro.observe(track);
		}

		// Initial state
		scheduleNavUpdate();
	};

	const initAll = () => {
		document.querySelectorAll('[data-slider]').forEach((root) => initSlider(root));
	};

	if (document.readyState === 'loading') {
		document.addEventListener('DOMContentLoaded', initAll, { once: true });
	} else {
		initAll();
	}
	})();
</script>

<style>
	.viewport {
		position: relative;
		overflow-x: auto;
		scroll-snap-type: x mandatory;
		-webkit-overflow-scrolling: touch;
		cursor: grab;
		touch-action: pan-y;
		/* Hide scrollbar visually while keeping scroll */
		scrollbar-width: none; /* Firefox */
		-ms-overflow-style: none; /* IE 10+ */
	}
	.viewport::-webkit-scrollbar { /* WebKit */
		width: 0;
		height: 0;
	}
	.viewport.dragging {
		cursor: grabbing;
		user-select: none;
	}
	.viewport.no-snap {
		scroll-snap-type: none;
	}

	.slide {
		flex: 0 0 100%;
		scroll-snap-align: start;
		padding: 0;
		margin: 0;
	}
	
	.slide-img {
		width: 100%;
		height: auto;
		display: block;
		user-select: none;
		pointer-events: none;
	}

	.nav.disabled {
		opacity: 0.25;
		pointer-events: none;
		cursor: default;
	}

	@media (prefers-reduced-motion: no-preference) {
		.viewport { scroll-behavior: smooth; }
	}
</style>
